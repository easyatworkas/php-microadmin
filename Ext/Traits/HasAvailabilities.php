<?php

/*
 * [x] Refactor
 * [x] Reformat
 * [x] Complete
 */

namespace Ext\Traits;

use Exception;
use Ext\Models\Availability;
use Ext\Models\Customer;
use Ext\Models\CustomerAvailability;
use Ext\Models\Employee;
use Ext\Models\EmployeeAvailability;
use Ext\Models\Model;

trait HasAvailabilities
{
    private function availabilityClass(): string
    {
        return match (getClass($this)) {
            Customer::class => CustomerAvailability::class,
            Employee::class => EmployeeAvailability::class,
            default => Availability::class
        };
    }

    public function manualAvailabilities(): array
    {
        try
        {
            return static::newQuery($this->getFullPath() . '/availabilities')
                ->setModel($this->availabilityClass())
                ->autogenerated(false)
                ->with([ 'days' ])
                ->getAll()
                ->all();
        }
        catch (Exception $e)
        {
            return [];
        }
    }

    public function autogeneratedAvailabilities(): array
    {
        try
        {
            return static::newQuery($this->getFullPath() . '/availabilities')
                ->setModel($this->availabilityClass())
                ->autogenerated(true)
                ->getAll()
                ->all();
        }
        catch (Exception $e)
        {
            return [];
        }
    }

    protected ?array $allAvailabilities = null;

    public function availabilities(): array
    {
        return !is_null($this->allAvailabilities)
            ? $this->allAvailabilities
            : $this->allAvailabilities = array_merge($this->manualAvailabilities(), $this->autogeneratedAvailabilities());
    }

    public function findAvailability(array $attributes = [], string $when = 'now'): ?Availability
    {
        foreach ($this->availabilities() as $availability) {
            if ($availability->matches($attributes)) {
                if (dateTimeWithin(dbTime($when), $availability->from, $availability->to)) {
                    return $availability;
                }
            }
        }
        return null;
    }

    public function findAvailabilities(array $attributes = [], string $myFrom = null, string $myTo = null): array
    {
        // If no params provided, return all
        if (empty($attributes) && is_null($myFrom) && is_null($myTo)) {
            return $this->availabilities();
        }

        $found = [];

        foreach ($this->availabilities() as $model) {
            if ($model->matches($attributes)) {
                if (intervalWithin($model->from, $model->to, dbTime($myFrom), dbTime($myTo))) {
                    $found[] = $model;
                }
            }
        }
        return $found;
    }

    public function getAvailability(string $key): ?Availability
    {
        $availability = null;
        try {
            $availability = static::newQuery($this->getFullPath() . "/availabilities/$key")
                ->setModel($this->availabilityClass())
                ->get();
        } catch (Exception $e) {
            // TODO: Log error
        }
        return $availability;
    }

    public function hasAvailability(array $attributes = [], string $when = 'now'): bool
    {
        return (bool)$this->findAvailability($attributes, $when);
    }
}